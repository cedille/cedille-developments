{- Parigot-encoded inductive datatypes.

   This development is generic in a functor.

   The interface you should use is:

   R         - the inductive type
   in/out    - constructing/destructing data of type R
   induction - dependent elimination on R
   recursion - non-dependent elimination on R (special case of induction, provided for convenience)
   -}

import functor.
module Parigot (F: ★ ➔ ★) (fmap: Fmap ·F)
               {fmapId: FmapId ·F fmap} {fmapCompose: FmapCompose ·F fmap}.

import recType.
import cast.
import functorThms · F fmap -fmapId -fmapCompose.
import sigma.
import top.

foldU    ◂ Top = β{λ alg. λ x. x alg}.
inU      ◂ Top = β{λ xs. λ alg. alg (fmap (λ x. mkpair x (foldU alg x)) xs)}.
reflectU ◂ Top = β{foldU (λ xs. inU (fmap snd xs))}.

Alg ◂ ★ ➔ ★ ➔ ★ = λ R: ★. λ X: ★. F ·(Pair ·R ·X) ➔ X.
RF  ◂ ★ ➔ ★ = λ R: ★. ι x: ∀ X: ★. Alg ·R ·X ➔ X. {reflectU x ≃ x}.

castFPair1 ◂ ∀ X: ★. ∀ Y: ★. Cast ·X ·Y ➔
  ∀ Z: ★. Cast ·(F ·(Pair ·X ·Z)) ·(F ·(Pair ·Y ·Z))
= Λ X. Λ Y. λ c. Λ Z. Mono-from-Functor (MonoPair1 c).

monoRF ◂ Mono ·RF = Λ X. Λ Y. λ c.
  intrCast -(λ x. [ Λ Z. λ alg. x.1 (λ xs. alg (elimCast -(castFPair1 c ·Z) xs))
                  , x.2 ])
           -(λ x. β).

R ◂ ★ = Rec ·RF.
roll   ◂ RF ·R ➔ R = elimCast -(recRoll -monoRF).
unroll ◂ R ➔ RF ·R = elimCast -(recUnroll -monoRF).

fold ◂ ∀ X: ★. Alg ·R ·X ➔ R ➔ X =
  Λ X. λ alg. λ r. (unroll r).1 alg.

_ : {fold ≃ foldU} = β.

inR1 ◂ F ·R ➔ ∀ X: ★. Alg ·R ·X ➔ X =
  λ rs. Λ X. λ alg. alg (fmap (λ r: R. mkpair r (fold alg r)) rs).

inR2 ◂ Π xs: F ·R. {reflectU (inR1 xs) ≃ inR1 xs} =
  λ xs. ρ+ (fmapCompose ·R (snd ·R ·Top) (λ x. mkpair x (β{reflectU x})) xs) -
        ρ+ (fmapId ·R ·Top (λ x. β{reflectU x}) (λ x. (unroll x).2) xs) -
        β.

in ◂ F ·R ➔ R = λ rs. roll [inR1 rs , ρ (inR2 rs) - β{inR1 rs}].
_ : {in ≃ inU} = β.

out ◂ R ➔ F ·R = λ d. (unroll d).1 ·(F ·R) (fmap (fst ·R ·(F ·R))).

PrfAlgGen ◂ Π R: ★. (F ·R ➔ R) ➔ (R ➔ ★) ➔ ★ =
  λ R: ★. λ in: F ·R ➔ R. λ P: R ➔ ★.
  Π d: F ·(Sigma ·R ·P). P (in (fmap (proj1 ·R ·P) d)).

PrfAlg ◂ (R ➔ ★) ➔ ★ = PrfAlgGen ·R in.

Inductive ◂ R ➔ ★ = λ r: R. ∀ P: R ➔ ★. PrfAlg ·P ➔ P r.

I ◂ ★ = ι x: R. Inductive x.

inI1 ◂ F ·I ➔ R = λ xs. in (fmap-cast -(intrCast ·I ·R -(λ x. x.1) -(λ x. β)) xs).

inI2 ◂ Π xs: F ·I. Inductive (inI1 xs) = λ xs. Λ P. λ alg.
  ρ  ς (fmapId (λ x: I. x.1) (λ x. β) xs) -
  ρ+ ς (fmapProj1Sigma ·I ·R ·P (λ x. x.1) (λ x. x.2 alg) xs) -
  alg (fmap (λ x: I. mksigma x.1 (x.2 ·P alg)) xs).

inI ◂ F ·I ➔ I = λ xs. [ inI1 xs , inI2 xs].

reflectI ◂ R ➔ I = λ x. fold (λ xs. inI (fmap (snd ·R ·I) xs)) x.

_ : {reflectI ≃ reflectU} = β.

castI ◂ Cast ·R ·I = intrCast -reflectI -(λ r. (unroll r).2).

induction ◂ ∀ P: R ➔ ★. PrfAlg ·P ➔ Π x: R. P x =
  Λ P. λ alg. λ x. (elimCast -castI x).2 alg.

_ : {induction ≃ fold} = β.

recursion ◂ ∀ X: ★. Alg ·R ·X ➔ R ➔ X = fold.
