{- Parigot-encoded inductive datatypes.

   This development is generic in a functor.

   The interface you should use is:

   R         - the inductive type
   in/out    - constructing/destructing data of type R
   induction - dependent elimination on R
   recursion - non-dependent elimination on R (special case of induction, provided for convenience)
   -}

import functor.
module Parigot (F: ★ ➔ ★) (fmap: Fmap ·F)
               {fmapId: FmapId ·F fmap} {fmapCompose: FmapCompose ·F fmap}.

import recType.
import cast.
import functorThms · F fmap -fmapId -fmapCompose.
import sigma.
import top.

foldU  ◂ Top = β{λ rec. λ d. d rec}.
inU    ◂ Top = β{λ ds. λ rec. rec (fmap (λ x. mkpair x (foldU rec x)) ds)}.
inAlgU ◂ Top = β{λ ds. inU (fmap snd ds)}.

Alg ◂ ★ ➔ ★ ➔ ★ = λ R: ★. λ X: ★. F ·(Pair ·R ·X) ➔ X.
RF  ◂ ★ ➔ ★ = λ R: ★. ι p: ∀ X: ★. Alg ·R ·X ➔ X. {foldU inAlgU p ≃ p}.

castFPair1 ◂ ∀ X: ★. ∀ Y: ★. Cast ·X ·Y ➔
  ∀ Z: ★. Cast ·(F ·(Pair ·X ·Z)) ·(F ·(Pair ·Y ·Z))
= Λ X. Λ Y. λ c. Λ Z. Mono-from-Functor (MonoPair1 c).

monoRF ◂ Mono ·RF = Λ X. Λ Y. λ c.
  caste -(λ x. [ Λ Z. λ alg. x.1 (λ xs. alg (cast -(castFPair1 c ·Z) xs))
               , x.2 ])
        -(λ x. β).

R ◂ ★ = Rec ·RF.
foldRF   ◂ RF ·R ➔ R = cast -(recFold -monoRF).
unfoldRF ◂ R ➔ RF ·R = cast -(recUnfold -monoRF).

fold ◂ ∀ X: ★. Alg ·R ·X ➔ R ➔ X =
  Λ X. λ alg. λ r. (unfoldRF r).1 alg.

_ : {fold ≃ foldU} = β.

inAlg ◂ F ·R ➔ ∀ X: ★. Alg ·R ·X ➔ X =
  λ rs. Λ X. λ alg. alg (fmap (λ r: R. mkpair r (fold alg r)) rs).

inReflection ◂ Π rs: F ·R. {foldU inAlgU (inAlg rs) ≃ inAlg rs}
= λ rs. (ρ+ (fmapSndPair ·R ·Top (λ x. β{fold inAlgU x}) rs) -
         ρ+ (fmapId ·R ·Top (λ x. β{fold inAlgU x}) (λ x. (unfoldRF x).2) rs) -
         β).

in ◂ F ·R ➔ R = λ rs. foldRF [inAlg rs , ρ (inReflection rs) - β{inAlg rs}].
_ : {in ≃ inU} = β.

out ◂ R ➔ F ·R = λ d. (unfoldRF d).1 ·(F ·R) (fmap (fst ·R ·(F ·R))).

lambek1 ◂ Π rs: F ·R. {out (in rs) ≃ rs} = λ rs.
  ρ (fmapFstPair (λ x: R. fold (fmap (fst ·R ·(F ·R))) x) rs) - β.

PrfAlg ◂ (R ➔ ★) ➔ ★ = λ P: R ➔ ★.
  Π d: F ·(Sigma ·R ·P). P (in (fmap (proj1 ·R ·P) d)).

Inductive ◂ R ➔ ★ = λ r: R. ∀ P: R ➔ ★. PrfAlg ·P ➔ P r.

I ◂ ★ = ι x: R. Inductive x.

castItoR ◂ Cast ·I ·R = caste -(λ x. x.1) -(λ x. β).

inI1 ◂ F ·I ➔ R = λ xs. in (cast -(Mono-from-Functor castItoR) xs).

inI2 ◂ Π xs: F ·I. Inductive (inI1 xs) = λ xs. Λ P. λ alg.
  ρ  ς (fmapId (λ x: I. x.1) (λ x. β) xs) -
  ρ+ ς (fmapProj1Sigma ·I ·R ·P (λ x. x.1) (λ x. x.2 alg) xs) -
  alg (fmap (λ x: I. mksigma x.1 (x.2 ·P alg)) xs).

inI ◂ F ·I ➔ I = λ xs. [ inI1 xs , inI2 xs].

toIAlg ◂ Alg ·R ·I = λ xs. inI (fmap (snd ·R ·I) xs).

castRtoI ◂ Cast ·R ·I =
  caste -(λ r. (unfoldRF r).1 toIAlg) -(λ r. (unfoldRF r).2).

induction ◂ ∀ P: R ➔ ★. PrfAlg ·P ➔ Π x: R. P x =
  Λ P. λ alg. λ x. (cast -castRtoI x).2 alg.

_ : {induction ≃ fold} = β.

recursion ◂ ∀ X: ★. Alg ·R ·X ➔ R ➔ X = fold.

lambek2 ◂ Π r: R. {in (out r) ≃ r}
= λ r. induction ·(λ x: R. {in (out x) ≃ x})
    (λ rs. ρ (lambek1 (fmap (proj1 ·R ·(λ x: R. {in (out x) ≃ x})) rs)) - β) r.
