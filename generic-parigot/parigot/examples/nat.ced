import utils.

module parigot/examples/nat.

import parigot/encoding as R ·NatF NatFmap -NatFmapId -NatFmapCompose.

Nat ◂ ★ = R.R.

zero ◂ Nat = R.in (in1 unit).
suc  ◂ Nat ➔ Nat = λ n. R.in (in2 n).

pred ◂ Nat ➔ Nat
= λ n. rec-Sum (R.out n) (λ _. n) (λ p. p).

_ ◂ {pred (suc zero) ≃ zero} = β.
_ ◂ Π x: Nat. {pred (suc x) ≃ x} = λ x. β.

natRec ◂ ∀ X: ★. X ➔ (Nat ➔ X ➔ X) ➔ Nat ➔ X
= Λ X. λ x. λ f.
  R.recursion (λ xs. rec-Sum xs (λ _. x) (λ p. rec-pair p (λ m. λ x. f m x))) .

natRecZ ◂ ∀ X: ★. ∀ x: X. ∀ f: (Nat ➔ X ➔ X). {natRec x f zero ≃ x}
= Λ X. Λ x. Λ f. β.

natRecS ◂ ∀ X: ★. ∀ x: X. ∀ f: (Nat ➔ X ➔ X). ∀ n: Nat. {natRec x f (suc n) ≃ f n (natRec x f n)}
= Λ X. Λ x. Λ f. Λ n. β.

natInd ◂ ∀ P: Nat ➔ ★. P zero ➔ (Π n: Nat. P n ➔ P (suc n)) ➔ Π n: Nat. P n
= Λ P. λ b. λ s.
  R.induction (λ xs.
    ind-Sum xs
     ·(λ x: Sum ·Unit ·(Sigma ·Nat ·P). P (R.in (NatFmap (proj1 ·Nat ·P) x)))
      (λ u. ρ (eta-Unit u) - b)
      (λ p. ind-sigma p ·(λ x: Sigma ·Nat ·P. P (R.in (NatFmap (proj1 ·Nat ·P) (in2 x))))
       (λ m. λ x. s m x))).

-- iteration
add ◂ Nat ➔ Nat ➔ Nat
= λ m. λ n. natRec m (λ _. λ x. suc x) n.

mult ◂ Nat ➔ Nat ➔ Nat
= λ m. λ n. natRec m (λ _. λ x. add n x) zero.

-- recursion
fac ◂ Nat ➔ Nat
= λ n. natRec n (λ m. λ x. mult (suc m) x) (suc zero).

addZRight ◂ Π n: Nat. {add n zero ≃ n}
= natInd ·(λ x: Nat. {add x zero ≃ x}) β (λ n. λ pf. ρ pf - β).
