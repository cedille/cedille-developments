import functor.
import utils.

module parigot/props
  (F: ★ ➔ ★) (fmap: Fmap ·F)
  {fmapId: FmapId ·F fmap} {fmapCompose: FmapCompose ·F fmap}.

import parigot/encoding ·F fmap -fmapId -fmapCompose.
import functorThms ·F fmap -fmapId -fmapCompose.

cancellation ◂ ∀ X: ★. Π xs: F ·R. Π a: Alg ·R ·X.
              { recursion a (in xs) ≃ a (fmap (λ r. mkpair r (recursion a r)) xs) } =
  Λ X. λ xs. λ a. β.

reflection ◂ Π x: R. {reflectI x ≃ x} = λ x. (unrollR x).2.

lambek1 ◂ Π rs: F ·R. {out (in rs) ≃ rs} =
  λ rs. ρ (fmapFstPair (λ x: R. recursion (fmap (fst ·R ·(F ·R))) x) rs) - β.

lambek2 ◂ Π r: R. {in (out r) ≃ r} =
  λ r. induction ·(λ x: R. {in (out x) ≃ x})
    (λ rs. ρ (lambek1 (fmap (proj1 ·R ·(λ x: R. {in (out x) ≃ x})) rs)) - β) r.

initial ◂ FmapExt ·F fmap ➔ ∀ X: ★. Π a: Alg ·R ·X. Π h: R ➔ X.
          Π hom: Π xs: F ·R. {h (in xs) ≃ a (fmap (λ r. mkpair r (h r)) xs)}.
          Π x: R. {h x ≃ recursion a x} =
  λ fext. Λ X. λ a. λ h. λ hom. λ x.
    induction ·(λ x: R. {h x ≃ recursion a x}) (
      λ xs. ρ+ (hom (fmap (proj1 ·R ·(λ x: R. {h x ≃ recursion a x})) xs)) -
            ρ+ (fmapCompose
                  (λ r: R. mkpair r (h r))
                  (λ p: Sigma ·R ·(λ x: R. {h x ≃ recursion a x}). proj1 p) xs) -
            ρ+ (fmapCompose
                  (λ r: R. mkpair r (recursion a r))
                  (λ p: Sigma ·R ·(λ x: R. {h x ≃ recursion a x}). proj1 p) xs) -
            ρ+ (fext ·(Sigma ·R ·(λ x: R. {h x ≃ recursion a x})) ·(Pair ·R ·X)
                  (λ p. mkpair (proj1 p) (h (proj1 p)))
                  (λ p. mkpair (proj1 p) (recursion a (proj1 p)))
                  (λ p. ρ+ (proj2 p) - β) xs) -
            β) x.
