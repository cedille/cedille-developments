import functor.
import utils.

module parigot/props
  (F: ★ ➔ ★) (fmap: Fmap ·F)
  {fmapId: FmapId ·F fmap} {fmapCompose: FmapCompose ·F fmap}.

import parigot/encoding ·F fmap -fmapId -fmapCompose.
import functorThms ·F fmap -fmapId -fmapCompose.

cancellation ◂ ∀ X: ★. Π xs: F ·P. Π a: AlgP ·P ·X.
  { recursion a (in xs) ≃ a (fmap (λ r. mkpair r (recursion a r)) xs) } =
  Λ X. λ xs. λ a. β.

reflection ◂ Π x: P. {reflectP x ≃ x} = λ x. (unrollP x).2.

lambek1 ◂ Π xs: F ·P. {out (in xs) ≃ xs} =
  λ xs. ρ (fmapFstPair (λ x: P. recursion (fmap (fst ·P ·(F ·P))) x) xs) - β.

lambek2 ◂ Π r: P. {in (out r) ≃ r} =
  λ r. induction ·(λ x: P. {in (out x) ≃ x})
    (λ rs. ρ (lambek1 (fmap (proj1 ·P ·(λ x: P. {in (out x) ≃ x})) rs)) - β) r.

unique ◂ FmapExt ·F fmap ➔ ∀ X: ★. Π a: AlgP ·P ·X. Π h: P ➔ X.
          Π hom: Π xs: F ·P. {h (in xs) ≃ a (fmap (λ r. mkpair r (h r)) xs)}.
          Π x: P. {h x ≃ recursion a x} =
  λ fext. Λ X. λ a. λ h. λ hom. λ x.
    induction ·(λ x: P. {h x ≃ recursion a x}) (
      λ xs. ρ+ (hom (fmap (proj1 ·P ·(λ x: P. {h x ≃ recursion a x})) xs)) -
            ρ+ (fmapCompose
                  (λ r: P. mkpair r (h r))
                  (λ p: Sigma ·P ·(λ x: P. {h x ≃ recursion a x}). proj1 p) xs) -
            ρ+ (fmapCompose
                  (λ r: P. mkpair r (recursion a r))
                  (λ p: Sigma ·P ·(λ x: P. {h x ≃ recursion a x}). proj1 p) xs) -
            ρ+ (fext ·(Sigma ·P ·(λ x: P. {h x ≃ recursion a x})) ·(Pair ·P ·X)
                  (λ p. mkpair (proj1 p) (h (proj1 p)))
                  (λ p. mkpair (proj1 p) (recursion a (proj1 p)))
                  (λ p. ρ+ (proj2 p) - β) xs) -
            β) x.
