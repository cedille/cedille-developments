import lib .

module large-elim/concrete/zipwith/nvecMap .

import tyvec .
import fold .

ArrTp : Î  n: Nat. ğ’ŒTyVec (succ n) â” â˜…
= Î» n: Nat. Î» L: ğ’ŒTyVec (succ n).
  TVFold Â·(Î» X: â˜…. Î» Y: â˜…. X â” Y) arrowRespTpEq2 n Â·L .

TVMapVec : Î  m: Nat. Î  n: Nat. ğ’ŒTyVec n â” ğ’ŒTyVec n
= Î» m: Nat. Î» n: Nat. Î» L: ğ’ŒTyVec n.
  TVMap Â·(Î» A: â˜…. Vec Â·A m) n Â·L .

ArrTpVec : Î  n: Nat. Nat â” ğ’ŒTyVec (succ n) â” â˜…
= Î» n: Nat. Î» m: Nat. Î» L: ğ’ŒTyVec (succ n).
  ArrTp n Â·(TVMapVec m (succ n) Â·L) .

arrTpVecZC
: âˆ€ m: Nat. âˆ€ L: ğ’ŒTyVec num1.
  TpEq Â·(ArrTpVec zero m Â·L) Â·(Vec Â·(TVHead zero Â·L) m)
= Î› m. Î› L. tvFoldZC -arrowRespTpEq2 Â·(TVMapVec m num1 Â·L) .

arrTpVecZC'
: âˆ€ m: Nat. âˆ€ X: â˜…. TpEq Â·(ArrTpVec zero m Â·(TVCons zero Â·X Â·TVNil)) Â·(Vec Â·X m)
= Î› m. Î› X.
  [L : ğ’ŒTyVec num1 = TVCons zero Â·X Â·TVNil]
- trans
    -(arrTpVecZC -m Â·L)
    -(vecRespTpEq -m -(tvHeadConsC -zero Â·X Â·TVNil))
.

arrTpVecSC
: âˆ€ m: Nat. âˆ€ n: Nat. âˆ€ L: ğ’ŒTyVec (add num2 n).
  TpEq Â·(ArrTpVec (succ n) m Â·L) Â·(Vec Â·(TVHead (succ n) Â·L) m â” ArrTpVec n m Â·(TVTail (succ n) Â·L))
= Î› m. Î› n. Î› L. tvFoldSC -arrowRespTpEq2 -n Â·(TVMapVec m (add num2 n) Â·L) .

arrTpVecSC'
: âˆ€ m: Nat. âˆ€ X: â˜…. âˆ€ n: Nat. âˆ€ L: ğ’ŒTyVec (succ n).
  TpEq Â·(ArrTpVec (succ n) m Â·(TVCons (succ n) Â·X Â·L)) Â·(Vec Â·X m â” ArrTpVec n m Â·L)
= Î› m. Î› X. Î› n. Î› L.
  [CL : ğ’ŒTyVec (add num2 n) = TVCons (succ n) Â·X Â·L]
- trans
   -(arrTpVecSC -m -n Â·CL)
   -(arrowRespTpEq2
      -(vecRespTpEq -m -(tvHeadConsC -(succ n) Â·X Â·L))
      -(tvFoldSubst -arrowRespTpEq2 -n
         -(tvMapRespEq -(vecRespTpEq -m) -(succ n)
            -(tvTailConsC -(succ n) Â·X Â·L))))
.

nvecMap
: Î  m: Nat. Î  n: Nat. âˆ€ L: ğ’ŒTyVec (succ n).
  ArrTp n Â·L â” ArrTpVec n m Â·L
= Î» m. Î» n. Î› L. Î» f.
  Î¼ go. n
  @(Î» x: Nat. âˆ€ L: ğ’ŒTyVec (succ x). Vec Â·(ArrTp x Â·L) m â” ArrTpVec x m Â·L) {
  | zero â” Î› L. Î» fs.
    tpEq2 -(arrTpVecZC -m Â·L)
      (tpEq1 -(vecRespTpEq -m -(tvFoldZC -arrowRespTpEq2 Â·L)) fs)
  | succ n' â” Î› L. Î» fs.
    [n'' = to/Nat -isType/go n']
  - [fs' = tpEq1 -(vecRespTpEq -m -(tvFoldSC -arrowRespTpEq2 -n'' Â·L)) fs ]
  - tpEq2 -(arrTpVecSC -m -n'' Â·L)
      (Î» a. go n' (vapp -m fs' a))
  } Â·L (vrepeat m f).


example : Vec Â·Nat num2
= [v : Vec Â·Nat num2
   = vcons -num1 num1 (vcons -zero num1 (vnil Â·Nat))]
- [Tl : ğ’ŒTyVec num1 = TVCons zero Â·Nat Â·TVNil]
- [L : ğ’ŒTyVec num2 = TVCons num1 Â·Nat Â·Tl]
-- sequence of type equalities
-- - for `f = add num10`
- [foldL : TpEq Â·(ArrTp num1 Â·L) Â·(Nat â” Nat)
   = trans
       -(tvFoldSC' -arrowRespTpEq2 -zero Â·Nat Â·Tl)
       -(arrowTpEqCod -(tvFoldZC' -arrowRespTpEq2 Â·Nat))]
- [f : ArrTp num1 Â·L = foldL.2.1 (add num10)]
-- - for nvecMap Â·L f
- [unfoldMapVecL : TpEq Â·(ArrTpVec num1 num2 Â·L) Â·(Vec Â·Nat num2 â” Vec Â·Nat num2)
   = trans
       -(arrTpVecSC' -num2 Â·Nat -zero Â·Tl)
       -(arrowTpEqCod -(arrTpVecZC' -num2 Â·Nat))]
- [vf : Vec Â·Nat num2 â” Vec Â·Nat num2
   = unfoldMapVecL.1.1 (nvecMap num2 num1 Â·L f)]
- vf v
.

_ : { example â‰ƒ nvecMap num2 num1 (add num10) (vcons num1 (vcons num1 vnil)) }
= Î² .
