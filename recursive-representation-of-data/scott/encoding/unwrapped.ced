import utils .
import functor .

module scott/encoding/unwrapped
  (F: ★ ➔ ★) (fmap: Fmap ·F)
  {fmapId: FmapId ·F fmap} {fmapCompose: FmapCompose ·F fmap} .

import functorThms ·F fmap -fmapId -fmapCompose .
import scott/encoding as S ·F -monoFunctor .

-- re-export some definitions
D ◂ ★ = S.D .
inD = S.inD .
outD = S.outD .
caseD = S.caseD .
wkIndD = S.wkIndD .
castWkSigmaD = S.castWkSigmaD .
inDWkSigma = S.inDWkSigma .

-- unwrapped definitions
inD' ◂ F ·D ➔ D
= λ xs. inD (fmap (wrap ·D) xs) .

caseD' ◂ ∀ X: ★. (F ·D ➔ X) ➔ D ➔ X
= Λ X. λ a. caseD λ xs. a (fmap (unwrap ·D) xs) .

outD' ◂ D ➔ F ·D = λ x. fmap (unwrap ·D) (outD x) .

caseDBeta' ◂ ∀ X: ★. ∀ a: F ·D ➔ X. ∀ xs: F ·D. { caseD' a (inD' xs) ≃ a xs }
= Λ X. Λ a. Λ xs.
  χ { a (fmap unwrap (fmap wrap xs)) ≃ a xs }
- ρ (fmapCompose (unwrap ·D) (wrap ·D) xs)
  @x.{ a x ≃ a xs }
- ρ (fmapId (λ x: D. unwrap (wrap x)) (λ _. β) xs)
  @x.{ a x ≃ a xs }
- β .

caseDEta' ◂ Π x: D. { caseD' inD' x ≃ x }
= wkIndD ·(λ x: D. { caseD' inD' x ≃ x })
    λ xs.
      [xs' ◂ F ·(Wrap ·D)
       = fcast -(castWkSigmaD ·(λ x: D. { caseD' inD' x ≃ x })) xs]
    - ρ (fmapCompose (wrap ·D) (unwrap ·D) xs')
      @x.{ inD x ≃ inDWkSigma xs }
    - ρ (fmapId ·(Wrap ·D) ·(Wrap ·D) (λ x. wrap (unwrap x)) (λ x. unwrapEta -x) xs')
      @x.{ inD x ≃ inDWkSigma xs }
    - β
.


lambek1D' ◂ Π xs: F ·D. { outD' (inD' xs) ≃ xs }
= λ xs. caseDBeta' ·(F ·D) -(λ x. x) -xs .

lambek2D' ◂ Π x: D. { inD' (outD' x) ≃ x }
= wkIndD ·(λ x: D. { inD' (outD' x) ≃ x })
    λ xs.
      [xs' : F ·(Wrap ·D)
       = fcast -(castWkSigmaD ·(λ x: D. { inD' (outD' x) ≃ x })) xs]
    - ρ (fmapCompose (wrap ·D) (unwrap ·D) xs')
      @x.{ inD x ≃ inDWkSigma xs }
    - ρ (fmapId ·(Wrap ·D) ·(Wrap ·D) (λ x. wrap (unwrap x)) (λ x. unwrapEta -x) xs')
      @x.{ inD x ≃ inDWkSigma xs }
    - β .

